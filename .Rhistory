t <- estimate_logk600(Wobs, Sobs)
#'Classify river for k600 prior assignment
#'
#'@param Wobs observed widths matrix
#'@param Sobs observed slopes matrix
classify_func_k600 <- function(Wobs, Sobs) {
Wobs[Wobs <= 0] <- NA
lwbar <- mean(log(Wobs), na.rm=TRUE)
Sobs[Sobs <= 0] <- NA
lsbar <- mean(log(Sobs), na.rm=TRUE)
classes <- c(log(10),
log(50),
log(100))
Sclass <- log(0.05)
index <- ifelse(lwbar < classes[1] & lsbar < 0.05, 1,
ifelse(lwbar < classes[1] & lsbar >= 0.05, 5,
ifelse(lwbar >= classes[1] & lwbar < classes[2], 2,
ifelse(lwbar >= classes[2] & lwbar < classes[3],3,4))))
print(index)
return(index)
}
t <- estimate_logk600(Wobs, Sobs)
exp(0.806)
mean(Sobs)
Wobs <- cbind(c(9,9,8,9),c(6,6,6,5), c(6,6,9,8), c(4,4,5,6))
t <- estimate_logk600(Wobs, Sobs)
mean(Sobs)
lsbar <- mean(log(Sobs), na.rm=TRUE)
#'Classify river for k600 prior assignment
#'
#'@param Wobs observed widths matrix
#'@param Sobs observed slopes matrix
classify_func_k600 <- function(Wobs, Sobs) {
Wobs[Wobs <= 0] <- NA
lwbar <- mean(log(Wobs), na.rm=TRUE)
Sobs[Sobs <= 0] <- NA
lsbar <- mean(log(Sobs), na.rm=TRUE)
classes <- c(log(10),
log(50),
log(100))
Sclass <- log(0.05)
index <- ifelse(lwbar < classes[1] & lsbar < Sclass, 1,
ifelse(lwbar < classes[1] & lsbar >= Sclass, 5,
ifelse(lwbar >= classes[1] & lwbar < classes[2], 2,
ifelse(lwbar >= classes[2] & lwbar < classes[3],3,4))))
print(index)
return(index)
}
t <- estimate_logk600(Wobs, Sobs)
lsbar <- mean(log(Sobs), na.rm=TRUE)
classes <- c(log(10),
log(50),
log(100))
Sclass <- log(0.05)
#'Classify river for k600 prior assignment
#'
#'@param Wobs observed widths matrix
#'@param Sobs observed slopes matrix
classify_func_k600 <- function(Wobs, Sobs) {
Wobs[Wobs <= 0] <- NA
lwbar <- mean(log(Wobs), na.rm=TRUE)
Sobs[Sobs <= 0] <- NA
lsbar <- mean(Sobs, na.rm=TRUE)
classes <- c(log(10),
log(50),
log(100))
Sclass <- 0.05
index <- ifelse(lwbar < classes[1] & lsbar < Sclass, 1,
ifelse(lwbar < classes[1] & lsbar >= Sclass, 5,
ifelse(lwbar >= classes[1] & lwbar < classes[2], 2,
ifelse(lwbar >= classes[2] & lwbar < classes[3],3,4))))
print(index)
return(index)
}
t <- estimate_logk600(Wobs, Sobs)
exp(4.38)
rstan:::rstudio_stanc("inst/stan/master.stan")
rstan:::rstudio_stanc("inst/stan/master.stan")
0.2724834*(2/3)
0.2724834*(3/2)
0.4366114*(3/2)
0.4366114*(2/3)
0.6624354*(3/2)
0.6624354*(2/3)
1.3160065*(3/2)
1.3160065*(2/3)
0.6488131*(3/2)
0.6488131*(2/3)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
matrix(5, nrow-4, ncol=4)
matrix(5, nrow=4, ncol=4)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
exp(11.6)
log(2.23)
log(2.03)
exp(-0.34)
10^-0.2
10^0.2
10^0.1
10^0.05
10^0
exp(0.26)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
library(BIKER)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
exp(4.7048)
0.657940*(-3/2)
0.657940*(2/3)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
w <- c(40,50,45,40)
reaches <- c(100,1200,1500,2000)
w*reaches
sum(w*reaches)
w <- c(40,50,45,40)
reaches <- c(100,1200,1500,2000)
r <- reaches
for (i in 1:length(reaches)) {
r[i] <- reaches[i] - reaches[i-1]
}
for (i in 2:length(reaches)) {
r[i] <- reaches[i] - reaches[i-1]
}
w <- c(40,50,45,40)
reaches <- c(500,1200,1500,2000)
r <- reaches
for (i in 2:length(reaches)) {
r[i] <- reaches[i] - reaches[i-1]
}
w <- c(180,195,189,180)
r <- c(10060, 9919, 9960, 12634)
sum(w*r)
3.941 + 0.818*28.5
3.941 + 0.818*1.4
exp(4.44383)
(3/2)*0.59957
(2/3)*0.59957
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
log(0.001)
log10(0.001)
10^-0.5
exp(-7.5)
exp(-2)
log10(exp(-2))
exp(-7.281)
log10(exp(-7.281))
log10(exp(-5.976))
exp(7.1266)
log10(exp(7.1266))
log10(exp(4.1266))
log10(exp(-2.22))
log10(exp(-6.43))
log10(4)
log(48)
0.0001^(1/2)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
10^-0.2
10^1
10^-2
10^-0.5
0.59957*(3/2)
0.59957*(2/3)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
S_obs <- c(c(4,5,4), c(6,7,8), c(6,7,5))
colSobs <- colMeans(log(Sobs), na.rm=T)
Sobs <- S_obs
colSobs <- colMeans(log(Sobs), na.rm=T)
colMeans(log(Sobs), na.rm=T)
Sobs <- matric(c(4,5,4), c(6,7,8), c(6,7,5))
Sobs <- matrix(c(4,5,4), c(6,7,8), c(6,7,5))
View(Sobs)
colMeans(log(Sobs), na.rm=T)
# khat <- 5.0941 + 0.6417*colSobs #ifelse(colSobs < -4.634, 3.22 + 0.347*colSobs, 6.85 + 1.13*colSobs)
khat <- log(1144.6*colMeans(Sobs, na.rm=T)) #r2 0.52 using ulseth data where Rh=H
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
roxygen2::roxygenise(load = "source")
roxygen2::roxygenise(load = "source")
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
rstan:::rstudio_stanc("inst/stan/master.stan")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
rstan:::rstudio_stanc("inst/stan/master.stan")
rstan:::rstudio_stanc("inst/stan/master.stan")
rstan:::rstudio_stanc("inst/stan/master.stan")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
exp(1.1653668 )
exp(1.5)
log(0.001)
log(500)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
9/16
11/16
rstan:::rstudio_stanc("inst/stan/master.stan")
rstan:::rstudio_stanc("inst/stan/master.stan")
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
install.packages('roxygen2')
install.packages("roxygen2")
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
9/16
11/16
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
47+17
46+17
31+16
47+17
47+16
exp(0.265191)
exp(-1.353)
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
getwd()
source("~/.active-rstudio-document", echo=TRUE)
i <- 1:10
outer(i, i, "*")
source("~/.active-rstudio-document", echo=TRUE)
system.time({print(seq(1,1000,1))})
2/12
(2/12) + 9/16
(2/12) + (9/16)
12*16
48/16
12*4
8+27
35/48
48/3
35/3
48/7
48/7
48/5
7/16
9/16
34/48
7/16
9/16
35/48
35/48
rstan:::rstudio_stanc("inst/stan/master.stan")
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
7/16
9/16
35/48
(2/3)*0.25
2/12
47.2*9.8^(7/16)*0.001^(9/16)
47.2*9.8^(7/16)*0.00001^(9/16)
exp(-0.24)
log(47.2*9.8^(7/16)*8.5e-5^(9/16))
log(47.2*9.8^(7/16)*5.5e-5^(9/16))
log(47.2*9.8^(7/16)*8.5e-4^(9/16))
log(47.2*9.8^(7/16)*1.16e-4^(9/16))
source('~/OneDrive - University of Massachusetts/Ongoing Projects/RSK600/src/swot_k_model_v3.R', echo=TRUE)
#######PRINT MODELS FOR PRIOR SPECIFICATIONS. THESE ARE MANUALLY IMPLEMENTED WITHIN BIKER BUT ARE CALCULATED USING THIS DATASET--------------------------
#khat prior model for BIKER. Basically the k model without depth as it isn't SWOT observable
hydraulicallyWide$term <- g^(7/16)*hydraulicallyWide$slope^(9/16)
lmPrior <- lm((k600)~term+0, data=hydraulicallyWide)
summary(lmPrior)
#######PRINT MODELS FOR PRIOR SPECIFICATIONS. THESE ARE MANUALLY IMPLEMENTED WITHIN BIKER BUT ARE CALCULATED USING THIS DATASET--------------------------
#khat prior model for BIKER. Basically the k model without depth as it isn't SWOT observable
hydraulicallyWide$term <- hydraulicallyWide$Qm3s #g^(7/16)*hydraulicallyWide$slope^(9/16)
lmPrior <- lm((k600)~term+0, data=hydraulicallyWide)
summary(lmPrior)
lmPrior <- lm(log(k600)~log(term), data=hydraulicallyWide)
summary(lmPrior)
#######PRINT MODELS FOR PRIOR SPECIFICATIONS. THESE ARE MANUALLY IMPLEMENTED WITHIN BIKER BUT ARE CALCULATED USING THIS DATASET--------------------------
#khat prior model for BIKER. Basically the k model without depth as it isn't SWOT observable
hydraulicallyWide$term <- g^(7/16)*hydraulicallyWide$slope^(9/16)
lmPrior <- lm(log(k600)~log(term), data=hydraulicallyWide)
summary(lmPrior)
#######PRINT MODELS FOR PRIOR SPECIFICATIONS. THESE ARE MANUALLY IMPLEMENTED WITHIN BIKER BUT ARE CALCULATED USING THIS DATASET--------------------------
#khat prior model for BIKER. Basically the k model without depth as it isn't SWOT observable
hydraulicallyWide$term <- hydraulicallyWide$Qm3s #g^(7/16)*hydraulicallyWide$slope^(9/16)
lmPrior <- lm(log(k600)~log(term), data=hydraulicallyWide)
summary(lmPrior)
exp(0.90)*16623^0.15
log(0.78)
log(10)
log(6)
log(3.45)
exp(30)
exp(.30)
source("C:/Users/cbrinkerhoff/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/utils.R", echo=TRUE)
cv2sigma(1)
library(devtools)
g
library(rlang)
library(testtha)
library(testthat)
install.packages('testthat')
install.packages("testthat")
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
install.packages('rstantools')
library(rstantools)
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
install.packages('covr')
install.packages('DT')
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
#' Convert coefficient of variation to sigma parameter of lognormal diistribution
#'
#' @param cv Coefficient of variation
#' @export
cv2sigma <- function (cv) {
sqrt(log(cv^2 + 1))
}
cv2sigma(1)
cv2sigma(0.5)
cv2sigma(0.3)
getwd()
#load in rivers
files <- list.files('C:/Users/craig/Documents/OneDrive - University of Massachusetts/Ongoing Projects/RSK600/data/Frasson_etal_2021/IdealDataxxxxxx', pattern="*.nc", full.names = TRUE) #pepsi 2
files2 <- list.files('C:/Users/craig/Documents/OneDrive - University of Massachusetts/Ongoing Projects/RSK600/data/Durand_etal_2016/xxxxxxxxxxxxxxxx', pattern="*.nc", full.names = TRUE) #pepsi 1
files <- c(files, files2)
#grab a dummy river
ashslough <- files[1]
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/debugRiver.R", echo=TRUE)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/debugRiver.R", echo=TRUE)
#extract river name-----------------------------------------------------------
name <- substr(currPepsi, 40, nchar(currPepsi))
name <- substr(name,1,nchar(name)-3)
#grab a dummy river
currPepsi <- files[1]
#extract river name-----------------------------------------------------------
name <- substr(currPepsi, 40, nchar(currPepsi))
name <- substr(name,1,nchar(name)-3)
set.seed(12)
#packages--------------------------------------------------------------------
library(ncdf4)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/debugRiver.R", echo=TRUE)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/debugRiver.R", echo=TRUE)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/dataprep.R", echo=TRUE)
#run BIKER------------------------------------------
data <- biker_data(w=W_obs, s=S_obs, dA=dA_obs, priorQ=as.matrix(priorQ))
View(data)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/prior_settings.R", echo=TRUE)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/estimate.R", echo=TRUE)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/priorCalc.R", echo=TRUE)
priors <- biker_priors(data)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/utils.R", echo=TRUE)
priors <- biker_priors(data)
priors$river_type_priors$logk_sd <- rep(0.30, ncol(W_obs)) #0.748
priors$sigma_model$sigma_post = matrix(uncertainity, nrow=nrow(W_obs), ncol=ncol(W_obs)) #For this validation, we only want Rh uncertainty. Real implementation would use full model uncertainty (calculate in '~src\swot_k_model.R')
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/debugRiver.R", echo=TRUE)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/stanmodels.R", echo=TRUE)
kest <- biker_estimate(bikerdata = data, bikerpriors = priors, meas_err=F,iter = 3000L) #meas err needs to be removed
library(rstan)
kest <- biker_estimate(bikerdata = data, bikerpriors = priors, meas_err=F,iter = 3000L) #meas err needs to be removed
rstan:::rstudio_stanc("inst/stan/master.stan")
kest <- biker_estimate(bikerdata = data, bikerpriors = priors, meas_err=F,iter = 3000L) #meas err needs to be removed
View(stanmodels)
kest <- biker_estimate(bikerdata = data, bikerpriors = priors, meas_err=F,iter = 3000L) #meas err needs to be removed
#reformat priors to a single list for stan
bikerpriors <- c(bikerpriors[[2]], bikerpriors[[3]])
kest <- biker_estimate(bikerdata = data, bikerpriors = priors, meas_err=F,iter = 3000L) #meas err needs to be removed
View(stanmodels)
stanfit <- stanmodels[["master"]]
View(stanfit)
bikerpriors <- priors
bikerdata <- data
#reformat priors to a single list for stan
bikerpriors <- c(bikerpriors[[2]], bikerpriors[[3]])
bikerinputs <- compose_biker_inputs(bikerdata, bikerpriors)
bikerinputs$inc <- 1
bikerinputs$meas_err <- ifelse(meas_error == TRUE, 1, 0)
meas)err <- 0
meas_err <- 0
stanfit <- stanmodels[["master"]]
if (is.null(pars)) {
pars <- c("man_rhs", "logWSpart",
"logktn", "logknbar",
"Sact", "dAact")
}
messageFlag <- ifelse(suppressOutput <= 0, FALSE, TRUE)
#generate stanfit object (i.e. sample from the posterior using stan)
fit <- sampling(stanfit, data = bikerinputs,
cores = cores, chains = chains, iter = iter,
pars = pars, include = include,
refresh = suppressOutput, show_messages = messageFlag,
...)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/priorCalc.R", echo=TRUE)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/estimate.R", echo=TRUE)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/prior_settings.R", echo=TRUE)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/dataprep.R", echo=TRUE)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/utils.R", echo=TRUE)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/stanmodels.R", echo=TRUE)
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/debugRiver.R", echo=TRUE)
#run BIKER------------------------------------------
data <- biker_data(w=W_obs, s=S_obs, dA=dA_obs, priorQ=as.matrix(priorQ))
priors <- biker_priors(data)
priors$river_type_priors$logk_sd <- rep(0.30, ncol(W_obs)) #0.748
priors$sigma_model$sigma_post = matrix(uncertainity, nrow=nrow(W_obs), ncol=ncol(W_obs)) #For this validation, we only want Rh uncertainty. Real implementation would use full model uncertainty (calculate in '~src\swot_k_model.R')
kest <- biker_estimate(bikerdata = data, bikerpriors = priors, meas_err=F,iter = 3000L) #meas err needs to be removed
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/zzz.R", echo=TRUE)
kest <- biker_estimate(bikerdata = data, bikerpriors = priors, meas_err=F,iter = 3000L) #meas err needs to be removed
rstan:::rstudio_stanc("inst/stan/master.stan")
rstan:::rstudio_stanc("inst/stan/master.stan")
rstan:::rstudio_stanc("inst/stan/master.stan")
rstan:::rstudio_stanc("inst/stan/master.stan")
rstan:::rstudio_stanc("inst/stan/master.stan")
log(62.82) + (0.4375)*log(9.8)
rstan:::rstudio_stanc("inst/stan/master.stan")
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/debugRiver.R", echo=TRUE)
#run BIKER------------------------------------------
data <- biker_data(w=W_obs, s=S_obs, dA=dA_obs, priorQ=as.matrix(priorQ))
priors <- biker_priors(data)
priors$river_type_priors$logk_sd <- rep(0.30, ncol(W_obs)) #0.748
rstan:::rstudio_stanc("inst/stan/master.stan")
0.5625/0.7291667
35/48
9/16
35/48 * 4
rstan:::rstudio_stanc("inst/stan/master.stan")
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
library(settings)
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
install.packages('roxygen2')
install.packages("roxygen2")
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
library(devtools)
load_al()
load_all()
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
pkgbuild::compile_dll() #this grabs everything and updates the actual package
roxygen2::roxygenise(load = "source") #This provides in-line function documentation
load_all()
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/debugRiver.R", echo=TRUE)
#Calculate observed k600 with no measurement error
D_obs <- area/W_obs #[m]
V_obs <- Q_obs/area #[m/s]
dA_obs <- calcdA_mat(W_obs,H_obs) #[m2]
source("~/OneDrive - University of Massachusetts/Ongoing Projects/BIKER/R/debugRiver.R", echo=TRUE)
D_obs <- area/W_obs #[m]
V_obs <- Q_obs/area #[m/s]
dA_obs <- calcdA_mat(W_obs,H_obs) #[m2]
k_obs <- k600_model(D_obs, S_obs, V_obs) #k600 equation
k_obs <- colMeans(k_obs, na.rm=T)
#run BIKER------------------------------------------
data <- biker_data(w=W_obs, s=S_obs, dA=dA_obs, priorQ=as.matrix(priorQ))
priors <- biker_priors(data)
priors$river_type_priors$logk_sd <- rep(0.30, ncol(W_obs)) #0.748
priors$sigma_model$sigma_post = matrix(uncertainity, nrow=nrow(W_obs), ncol=ncol(W_obs)) #For this validation, we only want Rh uncertainty. Real implementation would use full model uncertainty (calculate in '~src\swot_k_model.R')
kest <- biker_estimate(bikerdata = data, bikerpriors = priors, meas_err=F,iter = 3000L) #meas err needs to be removed
View(kest)
